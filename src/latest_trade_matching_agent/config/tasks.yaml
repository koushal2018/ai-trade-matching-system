document_processing_task:
  description: >
    Convert the PDF document at {document_path} to high-quality images.
    
    **CRITICAL: Determine output location from source PDF path:**
    - IF PDF is in .../BANK/... folder → Save images to s3://YOUR_S3_BUCKET/PDFIMAGES/BANK/[document_name]_[timestamp]/
    - IF PDF is in .../COUNTERPARTY/... folder → Save images to s3://YOUR_S3_BUCKET/PDFIMAGES/COUNTERPARTY/[document_name]_[timestamp]/
    - IF PDF location is unclear → Save to s3://YOUR_S3_BUCKET/PDFIMAGES/TEMP/[document_name]_[timestamp]/
    
    **WORKFLOW:**
    1. Parse the {document_path} to identify if it contains /BANK/ or /COUNTERPARTY/
    2. Set output S3 prefix based on source folder
    3. Convert PDF to high-resolution JPEG images (300 DPI)
    4. Save to S3 AND MUST also save locally to ./pdf_images/{unique_identifier}/ for next agent
    5. Use unique_identifier parameter to create separate folder per trade
    
    **OUTPUT REQUIREMENTS:**
    - Convert each page to high-resolution JPEG images for S3
    - MUST also save JPEG images locally to ./pdf_images/{unique_identifier}/ folder
    - Use save_locally: true and unique_identifier: {unique_identifier} parameters
    - Use 3-digit padding for page numbers: page_001.jpg, page_002.jpg, etc.
    - Create metadata.json with file list and conversion details
    - Provide the S3 folder path containing the images for the next agent
    
  expected_output: >
    Confirmation of successful conversion:
    - "Source PDF type: [BANK/COUNTERPARTY/UNKNOWN]"
    - "Images saved to: s3://YOUR_S3_BUCKET/PDFIMAGES/[BANK/COUNTERPARTY/TEMP]/[folder_name]/"
    - "Total pages converted: [X]"
    - S3 folder path for next agent
    
  agent: document_processor

trade_entity_extractor_task:
  description: >
    **CRITICAL DATA PRESERVATION & SOURCE IDENTIFICATION:** Extract comprehensive trade data from converted images.
    Document Path: {document_path}
    
    **MANDATORY WORKFLOW:**
    
    1. **ACCESS IMAGES:** 
       - Previous agent saved images locally to ./pdf_images/{unique_identifier}/ folder
       - Images are JPEG format with names like {unique_identifier}_page_001.jpg, {unique_identifier}_page_002.jpg, etc.
       - Use OCR tool to extract text from each local image file
       - CRITICAL: Use the exact path format: ./pdf_images/{unique_identifier}/{unique_identifier}_page_001.jpg
    
    2. **EXTRACT TEXT FROM IMAGES:**
       - Use OCR tool on local JPEG image files in ./pdf_images/{unique_identifier}/ folder
       - Ensure high accuracy in text extraction, preserving formatting and special characters  
    
    3. **IDENTIFY AND VALIDATE TRADE SOURCE:**
       Based on the folder where the images are saved (by the previous agent):
       - If in .../BANK/... folder → TRADE_SOURCE = "BANK"
       - If in .../COUNTERPARTY/... folder → TRADE_SOURCE = "COUN
      

    4. **SAVE JSON TO S3:**
       Create JSON with available data:

       Save the JSON file to  s3://YOUR_S3_BUCKET/extracted/
         - Folder based on TRADE_SOURCE (BANK or COUNTERPARTY)
         - Filename format: trade_[trade_id]_[timestamp].json
       
       - All extracted fields
     
   
       Use S3 Writer Tool to save the JSON file
    
  
   
  expected_output: >
    Save the JSON file to S3 and confirm:
    - "Extracted trade data saved to depending on the source: s3://YOUR_S3_BUCKET/extracted/[BANK/COUNTERPARTY]/trade_[trade_id]_[timestamp].json"
    - "TRADE_SOURCE identified as: [BANK/COUNTERPARTY]"
    - "Total fields extracted: [X]"
    - S3 path for next agent
   
  agent: trade_entity_extractor

reporting_task:
  description: >
    **CRITICAL TASK: Store trade data in the CORRECT DynamoDB table based on TRADE_SOURCE field**
    
    **IMPORTANT: The actual table names are:**
    - BankTradeData (for BANK trades)
    - CounterpartyTradeData (for COUNTERPARTY trades)
    
    **TABLE SELECTION RULES (MANDATORY):**
    - IF TRADE_SOURCE = "BANK" → Store in BankTradeData table
    - IF TRADE_SOURCE = "COUNTERPARTY" → Store in CounterpartyTradeData table
    - IF TRADE_SOURCE is missing or unclear → STOP and request clarification from previous agent
    
    **STRICT WORKFLOW (NO DEVIATIONS):**
    1. Get JSON file from S3 path provided by previous agent
    2. Parse the JSON string into a dictionary
    3. Parse the JSON string into a dictionary
    4. **CRITICAL STEP: Check TRADE_SOURCE field IMMEDIATELY**
       - Extract the TRADE_SOURCE field from the JSON
       - Validate it equals either "BANK" or "COUNTERPARTY" exactly
       - If missing or invalid, STOP and report error
    
    5. **TABLE SELECTION LOGIC (NEVER DEVIATE):**
       Pseudocode for table selection:
       - if TRADE_SOURCE == "BANK": use table_name = "BankTradeData"
       - elif TRADE_SOURCE == "COUNTERPARTY": use table_name = "CounterpartyTradeData"  
       - else: RAISE ERROR: "Invalid TRADE_SOURCE: [actual_value]. Must be BANK or COUNTERPARTY"
    
    6. **VERIFICATION BEFORE STORAGE:**
       - Log: "Preparing to store [source_type] trade in [table_name]"
       - Double-check the table selection is correct
       - If any doubt, STOP and ask for clarification
    
    **DATA STORAGE REQUIREMENTS:**
    - Use Trade_ID as the primary key for storage
    - If Trade_ID exists, update the record; if not, insert a new record
    - Include TRADE_SOURCE field in the stored record for audit trail
    - Ensure idempotent operations to prevent duplicates
    - Maintain data integrity and accuracy during storage
    - Log each storage action with timestamp, TRADE_SOURCE, and table name
    
    **ERROR HANDLING:**
    - If TRADE_SOURCE is missing: "ERROR: TRADE_SOURCE field not found in JSON. Cannot determine correct table."
    - If TRADE_SOURCE is invalid: "ERROR: Invalid TRADE_SOURCE value: [actual_value]. Expected BANK or COUNTERPARTY."
    - If wrong table detected: "CRITICAL ERROR: Found [source_type] trade incorrectly stored in [wrong_table_name]."
    
    **CONFIRMATION MESSAGE FORMAT:**
    "Successfully stored [source_type] trade [Trade_ID] in [table_name] table"
    
  expected_output: >
    Confirmation of successful storage containing:
    - "Stored [source_type] trade [Trade_ID] in [table_name]"
    - "Verification: BANK trades → BankTradeData, COUNTERPARTY trades → CounterpartyTradeData"
    - "Action: [inserted/updated]"
    - Database record count
    - NO additional commentary or suggestions
    
  agent: reporting_analyst
  
matching_task:
  description: >
    **CRITICAL TRADE MATCHING TASK - VERIFY CORRECT DATABASE STORAGE FIRST**
    
    **STEP 0: CRITICAL VERIFICATION (MUST DO FIRST)**
    Before ANY matching attempts, verify data integrity:
    1. Check BankTradeData table - ALL records should have TRADE_SOURCE = "BANK"
    2. Check CounterpartyTradeData table - ALL records should have TRADE_SOURCE = "COUNTERPARTY"
    3. If ANY trades are in wrong tables:
       - STOP IMMEDIATELY
       - Flag as CRITICAL ERROR
       - Report: "CRITICAL: Found [source_type] trades in wrong table [table_name]"
       - Demand correction before proceeding
    
    **ONLY PROCEED IF DATA IS CORRECTLY STORED**
    
    You need to match trades stored in DynamoDB Tables BankTradeData and CounterpartyTradeData
    If the tables do not exist or are empty, return an error message indicating the issue or ask the previous agent to populate them.
    
    **USE YOUR VETERAN EXPERTISE TO:**
    
    1. **VERIFY DATA INTEGRITY FIRST:**
       - Confirm ALL bank trades are in BankTradeData
       - Confirm ALL counterparty trades are in CounterpartyTradeData
       - Flag any misplaced trades as CRITICAL ERRORS
       - DO NOT attempt matching if trades are in wrong tables
    
    2. **ANALYZE DATA STRUCTURES:**
       - Examine both databases to understand their schemas and field naming conventions
       - Identify which fields map between systems (e.g., "Trade ID" vs "Reference Number")
       - Recognize counterparty-specific formatting patterns
       - Document any data quality issues or missing critical fields
    
    3. **APPLY PROFESSIONAL MATCHING LOGIC:**
       - Match ONLY between BankTradeData and CounterpartyTradeData (never within same table)
       - Use knowledge of what constitutes a match vs a break in real trading operations
       - Apply appropriate tolerances based on asset class and field type
       - Recognize rounding differences vs real discrepancies
       - Identify systematic booking problems vs one-off errors
    
    4. **PERFORM INTELLIGENT MATCHING (MUST COMPLETE):**
       - Step 4a: Get all trades from BankTradeData table
       - Step 4b: Get all trades from CounterpartyTradeData table
       - Step 4c: For each bank trade, search for matching counterparty trade using:
         * Trade ID/Reference Number matching
         * Trade Date matching (within tolerance)
         * Notional amount matching (within tolerance)
         * Counterparty name matching
       - Step 4d: Document all matches and breaks
       - Apply professional matching standards
       - Recognize when seeming differences are actually identical
       - Flag true exceptions that need escalation
    
    5. **CLASSIFY MATCHES PROFESSIONALLY:**
       Based on experience, categorize each trade comparison as:
       - MATCHED: Bank and counterparty trades align within tolerances
       - PROBABLE MATCH: Minor discrepancies between bank and counterparty versions
       - REVIEW REQUIRED: Discrepancies need human investigation
       - BREAK: Clear mismatch between bank and counterparty records
       - DATA ERROR: Trades in wrong tables or missing source identification
    
  expected_output: >
    **PROFESSIONAL MATCHING REPORT DELIVERABLES:**
    
    1. **DATA INTEGRITY CHECK:**
       - Confirmation that all BANK trades are in BankTradeData
       - Confirmation that all COUNTERPARTY trades are in CounterpartyTradeData
       - Any data integrity issues found and corrected
    
    2. **EXECUTIVE SUMMARY:**
       - Overall match rate between bank and counterparty trades
       - Key concerns or systematic issues identified
       - Comparison to typical match rates (70-95% expected)
    
    3. **DETAILED ANALYSIS REPORT:**
       Save to ./data/{unique_identifier}_matching_report.md containing:
       - Matched bank-to-counterparty trade pairs
       - Unmatched bank trades (no counterparty confirmation)
       - Unmatched counterparty trades (no bank record)
       - Field-level break analysis
       - Pattern recognition findings
       - Professional recommendations
    
    Message: "Matching completed between BankTradeData and CounterpartyTradeData. 
    Match rate: [X%]. Report saved to ./data/matching_report_[timestamp].md"
    
  agent: matching_analyst